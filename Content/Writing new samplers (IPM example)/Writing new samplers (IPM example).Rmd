---
title: "Writing new samplers (IPM example)"
author: "Perry de Valpine"
date: "September 2019"
output:
  slidy_presentation: default
  beamer_presentation: default
---
<style>
slides > slide {
  overflow-x: auto !important;
  overflow-y: auto !important;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      cache = FALSE)
library(nimble)
library(compareMCMCs)
library(coda)
recalculate <- TRUE
```

IPM example
=====
# Example: Woodchat Shrike

Thanks to Michael Schaub for this example.  (Where is it from?)

Michael's summary:

## Available data:
- marray: capture-recapture data in the marray format. It's a 3D array, the third dimension being the age (juvenile vs. adult)
- count: population counts in each year
- productivity data: vector J is the number of fledglings per year and B is the annual number of surveyed broods which give raise to the number of fledglings.

## Some features of the model:
- based on the life history of a passerine (2 age classes for survival, age at first reproduction = 1 year)
- includes demographic and environmental stochasticity (i.e temporal random effects on all demographic rates)


```{r}
## Thanks to Michael Schaub for this example

### Setup provided by Michael Schaub
# Example of an integrated population model for a woodchat shrike (passerine bird)

# Available data:
# - marray: capture-recapture data in the marray format. It's a 3D array, the third dimension being the age (juvenile vs. adult)
# - count: population counts in each year
# - productivity data: vector J is the number of fledglings per year and B is the annual number of surveyed broods which give raise to the number of fledglings.

# Some features of the model:
# - based on the life history of a passerine (2 age classes for survival, age at first reproduction = 1 year)
# - includes demographic and environmental stochasticity (i.e temporal random effects on all demographic rates)

##############################################

# Load data
load("WoodchatShrike.Rdata")

# Define a function which produces the necessary values to create a discrete uniform prior in JAGS using dcat  
disc.unif <- function(A, B){
  pprob <- c(rep(0, A-1), rep(1/(B-A+1), (B-A+1)))
  return(pprob)
}


## nimble model code,
## slightly modified from JAGS code
ipm_code <- nimbleCode({ 
  
  # Priors and linear models
  mean.logit.sj <- logit(mean.sj)
  mean.sj ~ dunif(0, 1) 
  mean.logit.sa <- logit(mean.sa)
  mean.sa ~ dunif(0, 1) 
  mean.p ~ dunif(0, 1)
  mean.log.f <- log(mean.f)
  mean.f ~ dunif(0, 10)
  
  for (t in 1:(n.occasions-1)){
    p[t] <- mean.p
  }
  
  for (t in 1:(n.occasions-1)){             
    logit.sj[t] <- mean.logit.sj + eps.sj[t]
    eps.sj[t] ~ dnorm(0, tau.sj)
    sj[t] <- ilogit(logit.sj[t])         # back transformation from logit scale
    logit.sa[t] <- mean.logit.sa + eps.sa[t]
    eps.sa[t] ~ dnorm(0, tau.sa)
    sa[t] <- ilogit(logit.sa[t])
  }
  
  for (t in 1:(n.occasions)){   
    log.f[t] <- mean.log.f + eps.f[t]
    eps.f[t] ~ dnorm(0, tau.f)
    f[t] <- exp(log.f[t])         # back transformation from log scale
  }
  
  sigma.sj ~ dunif(0, 10)
  tau.sj <- pow(sigma.sj, -2)
  sigma.sa ~ dunif(0, 10)
  tau.sa <- pow(sigma.sa, -2)
  sigma.f ~ dunif(0, 10)
  tau.f <- pow(sigma.f, -2)
  
  sigma.obs ~ dunif(0.5, 50)
  tau.obs <- pow(sigma.obs, -2)
  
  
  # State-space model for count data
  # Model for the initial population size
  N[1,1] ~ dcat(pNinit[])
  N[2,1] ~ dcat(pNinit[])
  
  # Process model over time
  for (t in 1:(n.occasions-1)){  
    N[1,t+1] ~ dpois(sj[t] * f[t] * (N[1,t] + N[2,t])) 
    N[2,t+1] ~ dbin(sa[t], (N[1,t] + N[2,t]))
  }
  
  # Observation model
  for (t in 1:n.occasions){
    count[t] ~ dnorm(N[1,t] + N[2,t], tau.obs)
  }
  
  
  # Poisson regression model for productivity data
  for (t in 1:n.occasions){
    J[t] ~ dpois(f[t] * B[t])
  }
  
  # Capture-recapture model (multinomial likelihood)
  # Define the multinomial likelihood
  for (t in 1:(n.occasions-1)){
    ## nimble needs more explicit indexing, so replace as follows.
    ## (An alternative is to use dimensions argument to nimbleModel.)
    ##   marr.j[t,1:n.occasions] ~ dmulti(pr.j[t,], rel.j[t])
    marr.j[t,1:n.occasions] ~ dmulti(pr.j[t,1:n.occasions], rel.j[t])
    ##    marr.a[t,1:n.occasions] ~ dmulti(pr.a[t,], rel.a[t])
    marr.a[t,1:n.occasions] ~ dmulti(pr.a[t,1:n.occasions], rel.a[t])
  }
  # Define the cell probabilities of the m-arrays
  # Main diagonal
  for (t in 1:(n.occasions-1)){
    q[t] <- 1-p[t]   # Probability of non-recapture
    pr.j[t,t] <- sj[t]*p[t]
    pr.a[t,t] <- sa[t]*p[t]
    # Above main diagonal
    for (j in (t+1):(n.occasions-1)){
      pr.j[t,j] <- sj[t]*prod(sa[(t+1):j])*prod(q[t:(j-1)])*p[j]
      pr.a[t,j] <- prod(sa[t:j])*prod(q[t:(j-1)])*p[j]
    } #j
    # Below main diagonal
    for (j in 1:(t-1)){
      pr.j[t,j] <- 0
      pr.a[t,j] <- 0
    } #j
  } #t
  # Last column: probability of non-recapture
  for (t in 1:(n.occasions-1)){
    pr.j[t,n.occasions] <- 1-sum(pr.j[t,1:(n.occasions-1)])
    pr.a[t,n.occasions] <- 1-sum(pr.a[t,1:(n.occasions-1)])
  } #t
  
  
  # Derived parameters
  # Total population size
  for (t in 1:(n.occasions)){
    Ntot[t] <- N[1,t] + N[2,t]
  }
} )


# Bundle data
bugs.data <- list(marr.j = marray[,,1], marr.a = marray[,,2], n.occasions = dim(marray)[2], rel.j = rowSums(marray[,,1]), rel.a = rowSums(marray[,,2]), J = J, B = B, count = count, pNinit = disc.unif(1, 300))

# Initial values
inits <- function(){list(mean.sj = runif(1, 0, 0.5), mean.sa = runif(1, 0.4, 0.6), mean.f = runif(1, 1.3, 2))}

## nimble takes initial values as a list, not a function
## (something we should probably allow)
initsVals <- inits()

# Parameters monitored
parameters <- c("mean.sj", "sj", "sigma.sj", "mean.sa", "sa", "sigma.sa", "mean.p", "mean.f", "f", "sigma.f", "sigma.obs", "N", "Ntot")
```

Look at the data
=====
```{r}
bugs.data$marr.a
bugs.data$marr.j
bugs.data$B
bugs.data$J
```

Try MCMC and study results
=====
```{r}
nimbleOptions(verbose = FALSE)
## 1. Build model
ipm_model <- nimbleModel(ipm_code,
                         constants = bugs.data,
                         inits = initsVals)
## 2. Build MCMC configuration and samplers:
ipm_mcmc <- buildMCMC(ipm_model)
## 3. Compile model via generated C++.
Cipm_model <- compileNimble(ipm_model)
## 4. Compile MCMC via generated C++
Cipm_mcmc <- compileNimble(ipm_mcmc, project = ipm_model)
## 5. Run MCMC. (nimble does not natively support multiple chains.)
# MCMC settings
ni <- 3000; nt <- 1; nb <- 1000; nc <- 3
samples <- runMCMC(Cipm_mcmc, ni)
colnames(samples)
```

Study results
=====
```{r study-mcmc-results}
## Pick a few trace plots
plot(samples[-c(1:1000),'N[1, 1]'], pch = '.') ## yuck
plot(samples[-c(1:1000),'N[1, 2]'], pch = '.') ## much better
plot(samples[-c(1:1000),'mean.p'], pch = '.') ## looks pretty good
## look at some pairs, dropped burnin = 500
pairs(samples[-(1:1000), 1:8], pch = '.')
## We see correlations in juvenile-adult pairs at eaach time,
## especially strongly for time 1.
## We also see time 1 posteriors being very wide.
pairs(samples[-(1:1000), 9:16], pch = '.')
## skip some
pairs(samples[-(1:1000), 21:28], pch = '.') 
## Look at ESS:
library(coda)
effectiveSize(samples)
## We see that the initial states mix poorly.
## Among parameters, mean.sj mixes worst.
## Is mean.sj correlated with anything?
cor(samples)[,'mean.sj']
```

Key points from studying default MCMC results
=====

- We see `mean.sj` is highly correlated with `mean.f`.

- This makes sense.  We might consider how to sample them jointly in a sensible way.

- But let's instead focus on the correlated adult-juvenile pairs.

- Sometimes mixing one part of a model more helps other parts mix tool.


Sample adults and juveniles jointly at each time
=====
```{r custom-sampler}
sampler_JuvAdult <- nimbleFunction(
  name = 'sampler_JuvAdult',
  contains = sampler_BASE,
  setup = function(model, mvSaved, target, control) {
    ## Much of this is bells and whistles
    adaptive      <- if(!is.null(control$adaptive))      control$adaptive      else TRUE
    adaptInterval <- if(!is.null(control$adaptInterval)) control$adaptInterval else 200
    scale         <- if(!is.null(control$scale))         control$scale         else 1
    adultMultiplier   <- if(!is.null(control$constantSum))   as.numeric(control$constantSum)   else as.numeric(1)
    calcNodes <- model$getDependencies(target)
    ##
    targetJuv <- target[1]
    targetAdult <- target[2]
    ## numeric value generation
    scaleOriginal <- scale
    timesRan      <- 0
    timesAccepted <- 0
    timesAdapted  <- 0
    optimalAR     <- 0.44
    gamma1        <- 0
    
  },
  run = function() {
    ## Here is the core of the sampler
    propLogScale <- 0
    propDiff <- round(rnorm(1, mean = 0, sd = scale))
    model[[targetJuv]] <<- model[[targetJuv]] + propDiff
    model[[targetAdult]] <<- model[[targetAdult]] + adultMultiplier * propDiff
    logMHR <- calculateDiff(model, calcNodes)
    jump <- decide(logMHR)
    if(jump) nimCopy(from = model, to = mvSaved, row = 1, nodes = calcNodes, logProb = TRUE)
    else     nimCopy(from = mvSaved, to = model, row = 1, nodes = calcNodes, logProb = TRUE)
    if(adaptive)     adaptiveProcedure(jump)
  },
  methods = list(
    ## The adaptation approach is copied directly from nimble source code for basic MH sampler
    adaptiveProcedure = function(jump = logical()) {
      timesRan <<- timesRan + 1
      if(jump)     timesAccepted <<- timesAccepted + 1
      if(timesRan %% adaptInterval == 0) {
        acceptanceRate <- timesAccepted / timesRan
        timesAdapted <<- timesAdapted + 1
        gamma1 <<- 1/((timesAdapted + 3)^0.8)
        gamma2 <- 10 * gamma1
        adaptFactor <- exp(gamma2 * (acceptanceRate - optimalAR))
        scale <<- scale * adaptFactor
        timesRan <<- 0
        timesAccepted <<- 0
      }
    },
    reset = function() {
      scale <<- scaleOriginal
      timesRan      <<- 0
      timesAccepted <<- 0
      timesAdapted  <<- 0
      gamma1 <<- 0
    }
  )
)
```

Function to make a configuration with the new sampler
=====
```{r}
configureMCMC_IPM <- function(model) {
  mcmcConf <- configureMCMC(model)
  mcmcConf$removeSamplers('N')
  Nnodes <- model$expandNodeNames('N')
  for(i in seq(1, length(Nnodes), by = 2)) {
    JuvAdultPair <- Nnodes[i:(i+1)]## e.g. c('N[1, 1]', 'N[2, 1]')
    mcmcConf$addSampler(JuvAdultPair,
                        type = sampler_JuvAdult,
                        control = list(adultMultiplier = 1))
    mcmcConf$addSampler(JuvAdultPair,
                        type = sampler_JuvAdult,
                        control = list(adultMultiplier = -1))
  }
  mcmcConf
}
```

Look at the configuration
=====
```{r}
custom_MCMC_conf <- configureMCMC_IPM(ipm_model)
custom_MCMC_conf$printSamplers()
```

Compare performance
```{r compare-performance}
nimbleOptions(verbose = FALSE)
ipm_comparison <- compareMCMCs(
    list(code = ipm_code,
         inits = initsVals,
         constants = bugs.data),
    MCMCs = c('nimble','jags','nimbleCustom'),
    nimbleMCMCdefs = list(nimbleCustom = configureMCMC_IPM),
    MCMCcontrol = list(burnin = 5000,
                       niter = 20000),
    monitors = parameters)
```

```{r}
make_MCMC_comparison_pages(ipm_comparison,
                           dir = "ipm_comparison",
                           modelName = "woodshrike")

```

Results are [here](ipm_comparison/woodshrike.html)
